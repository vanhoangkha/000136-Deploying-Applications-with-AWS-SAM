[
{
	"uri": "/vi/",
	"title": "Serverless - Triển khai ứng dụng với SAM",
	"tags": [],
	"description": "",
	"content": "Serverless - Triển khai ứng dụng với SAM Tổng quan Trong các bài trước của series này, chúng ta đã tìm hiểu cách xây dựng một ứng dụng web đơn giản theo mô hình serverless trên cách sử dụng bảng điều khiển của AWS. Để xây dựng ứng dụng serverless nhanh hơn, AWS cung cấp cho người dùng dịch vụ AWS Serverless Application Model (SAM) - là một open-source framework để xây dựng một ứng dụng serverless. SAM cung cấp cú pháp để diễn đạt các hàm, API, cơ sở dữ liệu và event source mappings. Chỉ với vài dòng cho mỗi tài nguyên, bạn có thể xác định ứng dụng bạn muốn và lập mô hình ứng dụng đó bằng YAML. Trong quá trình triển khai, SAM chuyển đổi và mở rộng cú pháp SAM thành cú pháp của AWS CloudFormation. Sau đó, CloudFormation cung cấp các tài nguyên cho người dùng.\nTrong bài này, chúng ta sẽ cùng nhau xây dựng lại ứng dụng web ở bài trước với AWS SAM.\nKiến trúc của ứng dụng chúng ta sẽ xây dựng:\nNội dung  Xác thực và lưu trữ Thiết lập APIs và Lambda function Kiểm tra API với Front-end Dọn dẹp tài nguyên  "
},
{
	"uri": "/vi/1-authenication-and-storage/1-1-deploy-cognito-and-s3/",
	"title": "Triển Khai Cognito Và S3 Bucket",
	"tags": [],
	"description": "",
	"content": "Trong phần này, chúng ta sẽ tạo Cognito User Pool, Identity Pool và S3 bucket lưu tệp tải lên dựa trên SAM:\nBạn cần cài đặt SAM CLI và cấu hình credentials trước khi thực hiện phần này.\n  Chạy câu lệnh sau để khởi tạo một SAM project:  #Step 1 - Download a sample application sam init  Chọn các thông tin như sau:   Which template source would you like to use? \t1 - AWS Quick Start Templates \t2 - Custom Template Location  Choice: 1   Choose an AWS Quick Start application template \t1 - Hello World Example \t2 - Multi-step workflow \t3 - Serverless API \t4 - Scheduled task \t5 - Standalone function \t6 - Data processing \t7 - Infrastructure event management \t8 - Machine Learning  Template: 1   Use the most popular runtime and package type? (Python and zip) [y/N]: y  Would you like to enable X-Ray tracing on the function(s) in your application? [y/N]: n  Project name [sam-app] : fcjdmssam Mở SAM project bằng trình chỉnh sửa. Mở tệp template.yaml   Xoá phần không cần thiết  Sao chép đoạn code sau vào phần Resources:   # Creates a user pool in cognito for your app to auth against  FcjDMSUserPool:  Type: AWS::Cognito::UserPool  Properties:  UserPoolName: \u0026#34;cognito-fcj-dms\u0026#34;  MfaConfiguration: \u0026#34;OFF\u0026#34;  AliasAttributes:  - preferred_username  - email  AutoVerifiedAttributes:  - email  EmailConfiguration:  EmailSendingAccount: COGNITO_DEFAULT  Policies:  PasswordPolicy:  MinimumLength: 8  RequireLowercase: true  RequireNumbers: true  RequireSymbols: false  RequireUppercase: true  TemporaryPasswordValidityDays: 30  UserAttributeUpdateSettings:  AttributesRequireVerificationBeforeUpdate:  - email   # Creates a User Pool Client to be used by the identity pool  FcjDMSUserPoolClient:  Type: AWS::Cognito::UserPoolClient  Properties:  ClientName: \u0026#34;fcj-dms\u0026#34;  UserPoolId: !Ref FcjDMSUserPool  GenerateSecret: false  ExplicitAuthFlows:  - ALLOW_USER_PASSWORD_AUTH  - ALLOW_CUSTOM_AUTH  - ALLOW_USER_SRP_AUTH  - ALLOW_REFRESH_TOKEN_AUTH   # Creates a federeated Identity pool  FcjDMSUserPoolIdentityPool:  Type: \u0026#34;AWS::Cognito::IdentityPool\u0026#34;  Properties:  IdentityPoolName: \u0026#34;fcj-dms-identity\u0026#34;  AllowUnauthenticatedIdentities: true  CognitoIdentityProviders:  - ClientId: !Ref FcjDMSUserPoolClient  ProviderName: !GetAtt FcjDMSUserPool.ProviderName Đoạn code dùng để khởi tạo các tài nguyên:\n Một User Pool: Cho phép người dùng đăng nhập bằng username, xác thực tài khoản bằng email và thiết lập chính sách mật khẩu Một User Pool Client: Cho phép người dùng kết hợp đăng nhập với mật khẩu và tích hợp với User Pool Một Identity Pool: Hỗ trợ thông tin chưa được xác thực và thiết lập user pool và client ID.  Chạy câu lệnh sau để build project:  sam build  Chạy dòng lệnh sau để kiểm tra SAM template có hợp lệ không:  sam validate  Chạy dòng lệnh dưới để triển khai SAM:  sam deploy --guided  Nhập tên cho stack: fcjdmsapp Nhập vùng mà bạn muốn triển khai, ví dụ: ap-southeast-1 Sau đó nhập các thông tin khác như hình dưới đây:   Đợi một lúc để tạo CloudFormation stack changeset Nhập y khi được hỏi Deploy this changeset?   Kết quả sau khi CloudFormation hoàn thành:  Mở bảng điều khiển của CloudFormation.   Chọn Stack details ở menu phía bên trái, sau đó chọn stack fcjdmsapp. Chọn tab Resources. Bạn sẽ thấy các tài nguyên mà mình đã mô tả trong template. Ấn vào FcjDmsUserPool để mở bảng điều khiển của user pool đó.  Tiếp theo chúng ta sẽ tạo một S3 bucket lưu các tệp mà người dùng tải lên.   Mở tệp template và thêm đoạn code sau để khai báo các tham số:  Parameters:  DocumentStoreBucketName:  Type: String  Default: fcjdmsstore  Thay đổi giá trị Default để thay đổi tên cho bucket\n  Thêm đoạn code sau vào tệp:   FcjDMSStore:  Type: AWS::S3::Bucket  Properties:  BucketName: !Ref DocumentStoreBucketName  CorsConfiguration:  CorsRules:  - AllowedHeaders:  - \u0026#39;*\u0026#39;  AllowedMethods:  - GET  - HEAD  - PUT  - POST  - DELETE  AllowedOrigins:  - \u0026#39;*\u0026#39;  ExposedHeaders:  - x-amz-server-side-encryption  - x-amz-request-id  - x-amz-id-2  - ETag  MaxAge: 1800 Với đoạn code trên, S3 bucket được thiết lập CorsRules cho phép ứng dụng web của chúng ta tương tác với nó.\nTiếp theo chúng ta sẽ tạo role cho các truy cập chưa xác thực và xác thực vào S3. Thêm đoạn code sau vào cuối tệp:   # Create a role for unauthorized access to AWS resources. Very limited access. Only allows users in the previously created  CognitoUnAuthorizedRole:  Type: \u0026#34;AWS::IAM::Role\u0026#34;  Properties:  AssumeRolePolicyDocument:  Version: \u0026#34;2012-10-17\u0026#34;  Statement:  - Effect: \u0026#34;Allow\u0026#34;  Principal:  Federated: \u0026#34;cognito-identity.amazonaws.com\u0026#34;  Action:  - \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;  Condition:  StringEquals:  \u0026#34;cognito-identity.amazonaws.com:aud\u0026#34;: !Ref FcjDMSUserPoolIdentityPool  \u0026#34;ForAnyValue:StringLike\u0026#34;:  \u0026#34;cognito-identity.amazonaws.com:amr\u0026#34;: unauthenticated  Policies:  - PolicyName: \u0026#34;CognitoUnauthorizedPolicy\u0026#34;  PolicyDocument:  Version: \u0026#34;2012-10-17\u0026#34;  Statement:  - Effect: \u0026#34;Allow\u0026#34;  Action:  - \u0026#34;mobileanalytics:PutEvents\u0026#34;  - \u0026#34;cognito-sync:*\u0026#34;  Resource: \u0026#34;*\u0026#34;  - Effect: \u0026#34;Allow\u0026#34;  Action:  - \u0026#34;s3:GetObject\u0026#34;  Resource: !Join  - \u0026#34;\u0026#34;  - - \u0026#34;arn:aws:s3:::\u0026#34;  - !Ref DocumentStoreBucketName  - /protected/*   # Create a role for authorized access to AWS resources. Control what your user can access. This example only allows Lambda invokation  # Only allows users in the previously created Identity Pool  CognitoAuthorizedRole:  Type: \u0026#34;AWS::IAM::Role\u0026#34;  Properties:  AssumeRolePolicyDocument:  Version: \u0026#34;2012-10-17\u0026#34;  Statement:  - Effect: \u0026#34;Allow\u0026#34;  Principal:  Federated: \u0026#34;cognito-identity.amazonaws.com\u0026#34;  Action:  - \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;  Condition:  StringEquals:  \u0026#34;cognito-identity.amazonaws.com:aud\u0026#34;: !Ref FcjDMSUserPoolIdentityPool  \u0026#34;ForAnyValue:StringLike\u0026#34;:  \u0026#34;cognito-identity.amazonaws.com:amr\u0026#34;: authenticated  Policies:  - PolicyName: \u0026#34;CognitoAuthorizedPolicy\u0026#34;  PolicyDocument:  Version: \u0026#34;2012-10-17\u0026#34;  Statement:  - Effect: \u0026#34;Allow\u0026#34;  Action:  - \u0026#34;mobileanalytics:PutEvents\u0026#34;  - \u0026#34;cognito-sync:*\u0026#34;  - \u0026#34;cognito-identity:*\u0026#34;  Resource: \u0026#34;*\u0026#34;  - Effect: \u0026#34;Allow\u0026#34;  Action:  - \u0026#34;lambda:InvokeFunction\u0026#34;  - \u0026#34;s3:GetObject\u0026#34;  - \u0026#34;s3:PutObject\u0026#34;  - \u0026#34;s3:DeleteObject\u0026#34;  Resource: \u0026#39;*\u0026#39;  - Effect: \u0026#34;Allow\u0026#34;  Action:  - \u0026#34;s3:GetObject\u0026#34;  Resource: !Join  - \u0026#34;\u0026#34;  - - \u0026#34;arn:aws:s3:::\u0026#34;  - !Ref DocumentStoreBucketName  - /protected/*   # Assigns the roles to the Identity Pool  IdentityPoolRoleMapping:  Type: \u0026#34;AWS::Cognito::IdentityPoolRoleAttachment\u0026#34;  Properties:  IdentityPoolId: !Ref FcjDMSUserPoolIdentityPool  Roles:  authenticated: !GetAtt CognitoAuthorizedRole.Arn  unauthenticated: !GetAtt CognitoUnAuthorizedRole.Arn Chạy các câu lệnh sau:  sam build sam deploy Tiếp theo chúng ta sẽ sử dụng amplify để import authentication và storage vào ứng dụng web của mình. Chạy câu lệnh sau tại thư mục gốc của front-end project.  amplify init   Nhập theo các thông tin dưới đây:\n? Enter a name for the project fcjdms\nThe following configuration will be applied:\nProject information\n| Name: fcjdms\n| Environment: dev\n| Default editor: Visual Studio Code\n| App type: javascript\n| Javascript framework: react\n| Source Directory Path: src\n| Distribution Directory Path: build\n| Build Command: npm run-script build\n| Start Command: npm run-script start\n? Initialize the project with the above configuration? Yes\nUsing default provider awscloudformation\n? Select the authentication method you want to use: AWS profile\nFor more information on AWS Profiles, see:\nhttps://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html\n? Please choose the profile you want to use default\n? Help improve Amplify CLI by sharing non sensitive configurations on failures (y/N) › No\n  Nếu chưa tải project thì chạy các câu lệnh sau:\ngit clone https://github.com/AWS-First-Cloud-Journey/FCJ-Serverless-DMS\ncd FCJ-Serverless-DMS\nnpm install\n Chạy câu lệnh sau để import authentication vào project:  amplify import auth  Chọn Cognito User Pool and Identity Pool cho What type of auth resource do you want to import?  Chạy câu lệnh sau để import storage vào project:  amplify import storage  Chọn S3 bucket - Content (Images, audio, video, etc.) cho Select from one of the below mentioned services Chọn bucket mà bạn đã tạo từ các bước trên  Chạy câu lệnh: amplify push để cập nhật tài nguyên cloud.  "
},
{
	"uri": "/vi/1-authenication-and-storage/",
	"title": "Xác thực và lưu trữ",
	"tags": [],
	"description": "",
	"content": "Trong phần này chúng ta sẽ tạo những tài nguyên cần thiết cho việc xác thực người dùng và hai S3 bucket để lưu tệp người dùng tải lên và host website tĩnh.\nNội dung  Triển khai Cognito và S3 bucket Triển khai Front-end  "
},
{
	"uri": "/vi/2-config-api-and-lambda-function/",
	"title": "Thiết Lập APIs Và Lambda Function",
	"tags": [],
	"description": "",
	"content": " Thêm đoạn code sau vào của tệp template.yaml trong sam project. Đoạn code mô tả một bảng DynamoDB với Partition key là id của user và Sort keylà tên tệp.   # Create a table to storage document informations  DocsTable:  Type: AWS::DynamoDB::Table  Properties:  TableName: Documents  BillingMode: PAY_PER_REQUEST  AttributeDefinitions:  - AttributeName: user_id  AttributeType: S  - AttributeName: file  AttributeType: S  KeySchema:  - AttributeName: user_id  KeyType: HASH  - AttributeName: file  KeyType: RANGE  StreamSpecification:  StreamViewType: NEW_IMAGE   # Create a table to storage general informations  GeneralTable:  Type: AWS::DynamoDB::Table  Properties:  TableName: General  BillingMode: PAY_PER_REQUEST  AttributeDefinitions:  - AttributeName: id  AttributeType: S  KeySchema:  - AttributeName: id  KeyType: HASH Sao chép đoạn code sau vào tệp template.yaml để thiết lập 5 Lambda function là:  upload_doc list_docs delete_doc upload_general_infor get_general_infor     # Lambda function to scan all document by user id  DocsList:  Type: AWS::Serverless::Function  Properties:  CodeUri: lambda/list_docs  Handler: list_docs.lambda_handler  Runtime: python3.9  FunctionName: list_docs  Architectures:  - x86_64  Policies:  - Statement:  - Sid: ReadDynamoDB  Effect: Allow  Action:  - dynamodb:Scan  - dynamodb:Query  Resource:  - !GetAtt DocsTable.Arn  Events:  ListDocs:  Type: Api  Properties:  Path: /docs/{id}  Method: get  RestApiId: !Ref DocApi  Environment:  Variables:  TABLE_NAME: !Ref DocsTable   # Lambda function to upload documents  DocsUpload:  Type: AWS::Serverless::Function  Properties:  CodeUri: lambda/upload_doc  Handler: upload_doc.lambda_handler  Runtime: python3.9  FunctionName: upload_doc  Architectures:  - x86_64  Policies:  - Statement:  - Sid: WriteToDynamoDB  Effect: Allow  Action:  - dynamodb:PutItem  Resource:  - !GetAtt DocsTable.Arn  Events:  UpoadDocs:  Type: Api  Properties:  Path: /docs  Method: post  RestApiId: !Ref DocApi  Environment:  Variables:  TZ: Asia/Jakarta  TABLE_NAME: !Ref DocsTable   # Lambda function to delete documents by user id  DocsDelete:  Type: AWS::Serverless::Function  Properties:  CodeUri: lambda/delete_doc  Handler: delete_doc.lambda_handler  Runtime: python3.9  FunctionName: delete_doc  Architectures:  - x86_64  Policies:  - Statement:  - Sid: DeleteItems  Effect: Allow  Action:  - dynamodb:DeleteItem  - dynamodb:GetItem  - dynamodb:Query  Resource:  - !GetAtt DocsTable.Arn  Events:  DeleteDoc:  Type: Api  Properties:  Path: /docs/{id}  Method: delete  RestApiId: !Ref DocApi  Environment:  Variables:  TABLE_NAME: !Ref DocsTable   GeneralInforUpload:  Type: AWS::Serverless::Function  Properties:  CodeUri: lambda/upload_general_infor  Handler: upload_general_infor.lambda_handler  Runtime: python3.9  FunctionName: upload_general_infor  Architectures:  - x86_64  Policies:  - Statement:  - Sid: DeleteItems  Effect: Allow  Action:  - dynamodb:PutItem  Resource:  - !GetAtt GeneralTable.Arn  Events:  DeleteDoc:  Type: Api  Properties:  Path: /docs/{id}/gen/  Method: post  RestApiId: !Ref DocApi  Environment:  Variables:  TABLE_NAME: !Ref GeneralTable   GeneralInforGet:  Type: AWS::Serverless::Function  Properties:  CodeUri: lambda/get_general_infor  Handler: get_general_infor.lambda_handler  Runtime: python3.9  FunctionName: get_general_infor  Architectures:  - x86_64  Policies:  - Statement:  - Sid: DeleteItems  Effect: Allow  Action:  - dynamodb:GetItem  - dynamodb:Query  Resource:  - !GetAtt GeneralTable.Arn  Events:  DeleteDoc:  Type: Api  Properties:  Path: /docs/{id}/gen/  Method: get  RestApiId: !Ref DocApi  Environment:  Variables:  TABLE_NAME: !Ref GeneralTable Tải tệp sau về và thêm vào thư mục gốc của sam project. Tệp này mô tả các API mà chúng ta cần.    Swagger   swagger.yaml  (6 ko)    Thêm đoạn code sau vào cuối tệp template.yaml để import tệp swagger.yaml.   # Create REST Api  DocApi:  Type: AWS::Serverless::Api  Properties:  StageName: dev  DefinitionBody:  \u0026#39;Fn::Transform\u0026#39;:  Name: \u0026#39;AWS::Include\u0026#39;  Parameters:  Location: \u0026#34;./swagger.yaml\u0026#34; Tạo thư mục và tệp: lambda/list_docs/list_docs.py Thêm code sau vào tệp list_docs.py  import json import boto3 import os from decimal import * from boto3.dynamodb.types import TypeDeserializer  dynamodb = boto3.client(\u0026#39;dynamodb\u0026#39;) serializer = TypeDeserializer()  class DecimalEncoder(json.JSONEncoder):  def default(self, obj):  if isinstance(obj, Decimal):  return str(obj)  return json.JSONEncoder.default(self, obj)  def deserialize(data):  if isinstance(data, list):  return [deserialize(v) for v in data]   if isinstance(data, dict):  try:  return serializer.deserialize(data)  except TypeError:  return {k: deserialize(v) for k, v in data.items()}  else:  return data  def lambda_handler(event, context):  table_name = os.environ[\u0026#39;TABLE_NAME\u0026#39;]  user_id = event[\u0026#39;pathParameters\u0026#39;][\u0026#39;id\u0026#39;]  print(user_id)  docs = dynamodb.query(  TableName=table_name,  KeyConditionExpression=\u0026#34;user_id = :id\u0026#34;,  ExpressionAttributeValues={ \u0026#34;:id\u0026#34;: { \u0026#39;S\u0026#39;: user_id } }  )   format_data_docs = deserialize(docs[\u0026#34;Items\u0026#34;])  # TODO implement  return {  \u0026#34;statusCode\u0026#34;: 200,  \u0026#34;headers\u0026#34;: {  \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;,  \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;,  \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET,PUT,POST,DELETE, OPTIONS\u0026#34;,  \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method,X-Access-Token,XKey,Authorization\u0026#34;  },  \u0026#34;body\u0026#34;: json.dumps(format_data_docs, cls=DecimalEncoder)  } Tương tự tạo thư mục và tệp upload_doc/upload_doc.py trong thư mục lambda. Tiếp theo sao chép code dưới đây cho tệp đã tạo.  import json import boto3 import os from datetime import datetime, timezone  dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) client_cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;)  def lambda_handler(event, context):  table_name = os.environ[\u0026#39;TABLE_NAME\u0026#39;]  now = datetime.now(tz=timezone.utc)  dt_string = now.strftime(\u0026#34;%d/%m/%Y %H:%M:%S\u0026#34;)  doc_data = json.loads(event[\u0026#34;body\u0026#34;])   path = \u0026#34;protected/{}/{}\u0026#34;.format(doc_data[\u0026#39;identityId\u0026#39;], doc_data[\u0026#39;file\u0026#39;])  doc_data.update({\u0026#34;path\u0026#34;: path, \u0026#34;modified\u0026#34;: dt_string})  table = dynamodb.Table(table_name)  table.put_item(Item = doc_data)   # TODO implement  return {  \u0026#39;statusCode\u0026#39;: 200,  \u0026#39;body\u0026#39;: \u0026#39;successfully upload!\u0026#39;,  \u0026#39;headers\u0026#39;: {  \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;,  \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Access-Control-Allow-Headers, Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method,X-Access-Token, XKey, Authorization\u0026#34;,  \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;,  \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET,PUT,POST,DELETE,OPTIONS\u0026#34;  }  }  Tương tự với tệp lambda/delete_doc/delete_doc.py  import json import boto3 import os  client = boto3.resource(\u0026#39;dynamodb\u0026#39;)  def lambda_handler(event, context):  # TODO implement  table_name = os.environ[\u0026#39;TABLE_NAME\u0026#39;]  error = None  doc_pk = event[\u0026#39;pathParameters\u0026#39;][\u0026#39;id\u0026#39;]  print(\u0026#34;doc_pk \u0026#34;, doc_pk)  doc_sk = event[\u0026#39;queryStringParameters\u0026#39;][\u0026#39;file\u0026#39;]  print(\u0026#34;doc_sk \u0026#34;, doc_sk)  table = client.Table(table_name)  key = {  \u0026#39;user_id\u0026#39;:doc_pk,  \u0026#39;file\u0026#39;: doc_sk  }   try:  table.delete_item(Key = key)  except Exception as e:  error = e    except Exception as e:  error = e   if error is None:  message = \u0026#39;successfully document item!\u0026#39;  else:  print(error)  message = \u0026#39;delete document fail\u0026#39;   return {  \u0026#39;statusCode\u0026#39;: 200,  \u0026#39;body\u0026#39;: message,  \u0026#39;headers\u0026#39;: {  \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;,  \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;  },  }  Tương tự với tệp lambda/upload_general_infor/upload_general_infor.py  import json import boto3 import os dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) def lambda_handler(event, context): table_name = os.environ[\u0026#39;TABLE_NAME\u0026#39;] data = json.loads(event[\u0026#34;body\u0026#34;]) table = dynamodb.Table(table_name) data.update({\u0026#34;id\u0026#34;: event[\u0026#39;pathParameters\u0026#39;][\u0026#39;id\u0026#39;]}) table.put_item(Item = data) # TODO implement return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: \u0026#39;successfully upload!\u0026#39;, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Access-Control-Allow-Headers, Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method,X-Access-Token, XKey, Authorization\u0026#34;, \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET,PUT,POST,DELETE,OPTIONS\u0026#34; } }  Tương tự với tệp lambda/get_general_infor/get_general_infor.py  import json import boto3 import os from decimal import * from boto3.dynamodb.types import TypeDeserializer dynamodb = boto3.client(\u0026#39;dynamodb\u0026#39;) serializer = TypeDeserializer() class DecimalEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, Decimal): return str(obj) return json.JSONEncoder.default(self, obj) def deserialize(data): if isinstance(data, list): return [deserialize(v) for v in data] if isinstance(data, dict): try: return serializer.deserialize(data) except TypeError: return {k: deserialize(v) for k, v in data.items()} else: return data def lambda_handler(event, context): # TODO implement table_name = os.environ[\u0026#39;TABLE_NAME\u0026#39;] user_id = event[\u0026#39;pathParameters\u0026#39;][\u0026#39;id\u0026#39;] print(user_id) data = dynamodb.query( TableName=table_name, KeyConditionExpression=\u0026#34;id = :id\u0026#34;, ExpressionAttributeValues={ \u0026#34;:id\u0026#34;: { \u0026#39;S\u0026#39;: user_id } } ) format_data = deserialize(data[\u0026#34;Items\u0026#34;]) return { \u0026#34;statusCode\u0026#34;: 200, \u0026#34;headers\u0026#34;: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET,PUT,POST,DELETE, OPTIONS\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method,X-Access-Token,XKey,Authorization\u0026#34; }, \u0026#34;body\u0026#34;: json.dumps(format_data, cls=DecimalEncoder) #\u0026#34;body\u0026#34;: format_data } Chạy câu lệnh dưới đây để build và deploy sam project sau khi cập nhật template:  sam build sam deploy Trong lúc đợi CloudFormation hoàn thành, bạn có thể tìm hiểu về tệp swagger.yaml. Phần tiếp theo chúng ta sẽ thực hiện các thao tác trên Front-end để kiểm tra hoạt động của các API.\n"
},
{
	"uri": "/vi/1-authenication-and-storage/1-2-deploy-front-end/",
	"title": "Triển Khai Front-end",
	"tags": [],
	"description": "",
	"content": " Thêm đoạn code sau tại phần Prarameters của tệp template.yaml trong sam project:   WebStoreBucketName:  Type: String  Default: fcjdmswebstore  Thay đổi giá trị Default để thay đổi tên cho bucket\n Thêm đoạn code sau bên dưới mô tả S3 bucket ở phần 1.1. Đoạn code này mô tả bucket cho phép truy cập public và enable hosting website:   FcjDMSWebStore:  Type: AWS::S3::Bucket  Properties:  BucketName: !Ref WebStoreBucketName  PublicAccessBlockConfiguration:  BlockPublicAcls: \u0026#34;false\u0026#34;  BlockPublicPolicy: \u0026#34;false\u0026#34;  WebsiteConfiguration:  IndexDocument: \u0026#39;index.html\u0026#39;   FcjDMSWebStorePolicy:  Type: AWS::S3::BucketPolicy  Properties:  Bucket: !Ref FcjDMSWebStore  PolicyDocument:  Version: 2012-10-17  Statement:  - Action:  - \u0026#34;s3:GetObject\u0026#34;  Effect: Allow  Principal: \u0026#34;*\u0026#34;  Resource: !Join  - \u0026#34;\u0026#34;  - - \u0026#34;arn:aws:s3:::\u0026#34;  - !Ref FcjDMSWebStore  - /* Chạy câu lệnh sau để build và deploy lại sam project:  sam build sam deploy Quay lại với thư mục gốc của Front-end project, chạy câu lệnh sau:  yarn build aws s3 cp build s3://BUCKET_NAME --recursive Thay thế BUCKET_NAME bằng tên bucket bạn vừa tạo để host website, ví dụ: aws s3 cp build s3://fcjdmswebstore --recursive\nMở bảng điều khiển của Amazon S3   Chọn bucket vừa tạo  Chọn tab Properties và kéo xuống cuối cùng. Ấn vào URL của website  Ấn Sign up  Nhập tên người dùng, email và mật khẩu. Sau đó ấn Sign up  Mở email để lấy verify code và nhập vào trang web. Sau đó ấn Submit  Quay lại với bảng điều khiển của Cognito User Pool, ấn sang tab User bạn sẽ thấy tài khoản mình vừa đăng ký.  Đăng nhập vào website bằng tài khoản vừa đăng ký.  Đăng nhập thành công  Chọn My Profile ở menu phía bên trái, tiếp theo ấn Update profile.  Nhập mật khẩu cũ và mới, sau đó ấn Upadate  Ấn OK  Ấn Sign out ở menu phía bên trái  Ấn Sign in  Đăng nhập lại với tài khoản mà bạn vừa cập nhật.  Bạn đã đăng nhập thành công với thông tin tài khoản mới.  Bạn đã hoàn thành việc host một website tĩnh trên S3, xác thực người dùng với Cognito, lưu trữ tài liệu trên S3. Tiếp theo chúng tã sẽ thiết lập REST API cho ứng dụng.\n"
},
{
	"uri": "/vi/3-test-api-with-front-end/",
	"title": "Kiểm Tra API Với Front-end",
	"tags": [],
	"description": "",
	"content": "Chúng ta sẽ thực hiện các chức năng tải tài liệu lên, tải tài liệu về và xoá tài liệu để kiểm tra hoạt động của các API.\n Mở bảng điều khiển của stack fcjdms, ấn vào id của DocAPI  Chọn Stages, sau đó mở rộng stage dev và ghi lại URL của API  Mở tệp constant.js trong thư mục src của front-end project đã được tải về từ phần 2 Thay giá trị cho APP_API_URL bằng URL của bạn:   Mở tệp src/component/Home/Upload.js trong thư mục source code của ứng dụng và bỏ comment đoạn code gọi API ghi dữ liệu vào DynamoDB.  Build và đẩy thư mục build lên s3 với câu lệnh sau:  yarn build aws s3 cp build s3://BUCKET_NAME --recursive Thay thế BUCKET_NAME bằng tên bucket bạn tạo để host website\nTrở lại với trình duyệt web với ứng dụng của bạn và reload lại trang.   Ấn Upload  Ấn Add files và chọn các tệp mà bạn muốn tải lên. Sau đó ấn Upload   Chọn My Profile để xem thông tin các số tệp và dung lượng đã dùng  Chọn My Document ở menu phía bên trái để xem các tệp đã tải lên. Sau đó ấn Select  Chọn các tệp mà bạn muốn xoá và ấn Delete   Ấn OK để xác nhận xoá  Bạn sẽ thấy các tệp đã được xoá và bạn có thể tải tệp về máy nếu ấn vào biểu tượng Download  Chọn Home ở menu phía bên trái, bạn sẽ thấy thông tin đã được cập nhật  Bạn có thể mở S3 bucket và DynamoDB table để kiểm tra các object và dữ liệu. Chúng ta đã hoàn thành việc triển khai ứng dụng serverless với SAM.\n"
},
{
	"uri": "/vi/4-cleanup/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": " Làm rỗng S3 bucket   Chạy câu lệnh sau: aws s3 rm s3://BUCKET_NAME --recursive Thay thế BUCKET_NAME bằng tên bucket cần làm rỗng: fcjdmswebstore, fcjdmsstore  Chạy các câu lệnh sau tại thư mục gốc của front-end project:  amplify remove storage amplify remove auth amplify push amplify delete Xoá stack của CloudFormation   Chạy câu lệnh dưới đây để xoá ứng dụng AWS SAM: sam delete --stack-name fcjdmsapp Chạy câu lệnh sau để làm rỗng S3 bucket: aws s3 rm s3://BUCKET_NAME --recursive Thay thế BUCKET_NAME bằng tên bucket bắt đầu bằng: aws-sam-cli-managed-default-samclisourcebucket- Mở bảng điều khiển của Amazon S3 Chọn bucket bắt đầu bằng aws-sam-cli-managed-default-samclisourcebucket- Ấn Show versions Chọn thư mục fcjdmsapp Chọn tất cả các object Ấn Delete Nhập permanently delete Ấn Delete Chạy câu lệnh sau để xoá stack: sam delete --stack-name aws-sam-cli-managed-default  "
},
{
	"uri": "/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]