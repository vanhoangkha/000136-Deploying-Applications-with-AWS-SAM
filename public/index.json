[
{
	"uri": "/1-authenication-and-storage/",
	"title": "Authentication And Storage",
	"tags": [],
	"description": "",
	"content": "In this section we will create the necessary resources for user authentication and two S3 buckets to store user uploads and host a static website.\nContent  Deploy Cognito And S3 bucket Deploy Front-end  "
},
{
	"uri": "/1-authenication-and-storage/1-1-deploy-cognito-and-s3/",
	"title": "Deploy Cognito And S3 Bucket",
	"tags": [],
	"description": "",
	"content": "In this section, we will create a Cognito User Pool, Identity Pool, and S3 bucket that stores file uploads with SAM:\nYou need install SAM CLI and configure credentials before doing this part.\n  Run the following command to initialize a SAM project:  #Step 1 - Download a sample application sam init  Select the following information:   Which template source would you like to use? \t1 - AWS Quick Start Templates \t2 - Custom Template Location  Choice: 1   Choose an AWS Quick Start application template \t1 - Hello World Example \t2 - Multi-step workflow \t3 - Serverless API \t4 - Scheduled task \t5 - Standalone function \t6 - Data processing \t7 - Infrastructure event management \t8 - Machine Learning  Template: 1   Use the most popular runtime and package type? (Python and zip) [y/N]: y  Would you like to enable X-Ray tracing on the function(s) in your application? [y/N]: n  Project name [sam-app] : fcjdmssam Open SAM project by IDE. Open template.yaml file.   Delete unnecessary part  Copy the following code into the Resources section:   # Creates a user pool in cognito for your app to auth against  FcjDMSUserPool:  Type: AWS::Cognito::UserPool  Properties:  UserPoolName: \u0026#34;cognito-fcj-dms\u0026#34;  MfaConfiguration: \u0026#34;OFF\u0026#34;  AliasAttributes:  - preferred_username  - email  AutoVerifiedAttributes:  - email  EmailConfiguration:  EmailSendingAccount: COGNITO_DEFAULT  Policies:  PasswordPolicy:  MinimumLength: 8  RequireLowercase: true  RequireNumbers: true  RequireSymbols: false  RequireUppercase: true  TemporaryPasswordValidityDays: 30  UserAttributeUpdateSettings:  AttributesRequireVerificationBeforeUpdate:  - email   # Creates a User Pool Client to be used by the identity pool  FcjDMSUserPoolClient:  Type: AWS::Cognito::UserPoolClient  Properties:  ClientName: \u0026#34;fcj-dms\u0026#34;  UserPoolId: !Ref FcjDMSUserPool  GenerateSecret: false  ExplicitAuthFlows:  - ALLOW_USER_PASSWORD_AUTH  - ALLOW_CUSTOM_AUTH  - ALLOW_USER_SRP_AUTH  - ALLOW_REFRESH_TOKEN_AUTH   # Creates a federeated Identity pool  FcjDMSUserPoolIdentityPool:  Type: \u0026#34;AWS::Cognito::IdentityPool\u0026#34;  Properties:  IdentityPoolName: \u0026#34;fcj-dms-identity\u0026#34;  AllowUnauthenticatedIdentities: true  CognitoIdentityProviders:  - ClientId: !Ref FcjDMSUserPoolClient  ProviderName: !GetAtt FcjDMSUserPool.ProviderName This code block used to initialize resources:\n A User Pool: Allow users sign in by username, authenticate account by email and config password policies. A User Pool Client: Allow users sign in with a combination password and user name and integrate with User Pool. A Identity Pool: Supports unauthenticated credentials and user pool and client ID settings.  Run below command to build project:  sam build  Run the below command to check if the SAM template is valid or not:  sam validate  Run the below command to deploy SAM:  sam deploy --guided  Enter stack name: fcjdmsapp Enter region you want deploy, such as: ap-southeast-1 hen, enter other information as the below figure:   Wait a while to create CloudFormation stack changeset Enter y when is ask Deploy this changeset?   The result after CloudFormation is completed:  Open CloudFormation console.   Select Stack details on the left menu, then select fcjdmsapp stack. Select Resources tab. You will see the resources we described in the template. Click FcjDmsUserPool to navigate to this User Pool console.  Next, we will create a S3 bucket to store files that the user uploads   Open template file and add the following code to declare the parameters::  Parameters:  DocumentStoreBucketName:  Type: String  Default: fcjdmsstore  Change the Default value to change bucket name\n  Add the following code to file:   FcjDMSStore:  Type: AWS::S3::Bucket  Properties:  BucketName: !Ref DocumentStoreBucketName  CorsConfiguration:  CorsRules:  - AllowedHeaders:  - \u0026#39;*\u0026#39;  AllowedMethods:  - GET  - HEAD  - PUT  - POST  - DELETE  AllowedOrigins:  - \u0026#39;*\u0026#39;  ExposedHeaders:  - x-amz-server-side-encryption  - x-amz-request-id  - x-amz-id-2  - ETag  MaxAge: 1800 With the above code, the S3 bucket is configured CorsRules which allows our web application access to it.\nNext, we will create the roles for unauthorized and authorized access to S3. Add the following code to the bottom file:   # Create a role for unauthorized access to AWS resources. Very limited access. Only allows users in the previously created  CognitoUnAuthorizedRole:  Type: \u0026#34;AWS::IAM::Role\u0026#34;  Properties:  AssumeRolePolicyDocument:  Version: \u0026#34;2012-10-17\u0026#34;  Statement:  - Effect: \u0026#34;Allow\u0026#34;  Principal:  Federated: \u0026#34;cognito-identity.amazonaws.com\u0026#34;  Action:  - \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;  Condition:  StringEquals:  \u0026#34;cognito-identity.amazonaws.com:aud\u0026#34;: !Ref FcjDMSUserPoolIdentityPool  \u0026#34;ForAnyValue:StringLike\u0026#34;:  \u0026#34;cognito-identity.amazonaws.com:amr\u0026#34;: unauthenticated  Policies:  - PolicyName: \u0026#34;CognitoUnauthorizedPolicy\u0026#34;  PolicyDocument:  Version: \u0026#34;2012-10-17\u0026#34;  Statement:  - Effect: \u0026#34;Allow\u0026#34;  Action:  - \u0026#34;mobileanalytics:PutEvents\u0026#34;  - \u0026#34;cognito-sync:*\u0026#34;  Resource: \u0026#34;*\u0026#34;  - Effect: \u0026#34;Allow\u0026#34;  Action:  - \u0026#34;s3:GetObject\u0026#34;  Resource: !Join  - \u0026#34;\u0026#34;  - - \u0026#34;arn:aws:s3:::\u0026#34;  - !Ref DocumentStoreBucketName  - /protected/*   # Create a role for authorized access to AWS resources. Control what your user can access. This example only allows Lambda invokation  # Only allows users in the previously created Identity Pool  CognitoAuthorizedRole:  Type: \u0026#34;AWS::IAM::Role\u0026#34;  Properties:  AssumeRolePolicyDocument:  Version: \u0026#34;2012-10-17\u0026#34;  Statement:  - Effect: \u0026#34;Allow\u0026#34;  Principal:  Federated: \u0026#34;cognito-identity.amazonaws.com\u0026#34;  Action:  - \u0026#34;sts:AssumeRoleWithWebIdentity\u0026#34;  Condition:  StringEquals:  \u0026#34;cognito-identity.amazonaws.com:aud\u0026#34;: !Ref FcjDMSUserPoolIdentityPool  \u0026#34;ForAnyValue:StringLike\u0026#34;:  \u0026#34;cognito-identity.amazonaws.com:amr\u0026#34;: authenticated  Policies:  - PolicyName: \u0026#34;CognitoAuthorizedPolicy\u0026#34;  PolicyDocument:  Version: \u0026#34;2012-10-17\u0026#34;  Statement:  - Effect: \u0026#34;Allow\u0026#34;  Action:  - \u0026#34;mobileanalytics:PutEvents\u0026#34;  - \u0026#34;cognito-sync:*\u0026#34;  - \u0026#34;cognito-identity:*\u0026#34;  Resource: \u0026#34;*\u0026#34;  - Effect: \u0026#34;Allow\u0026#34;  Action:  - \u0026#34;lambda:InvokeFunction\u0026#34;  - \u0026#34;s3:GetObject\u0026#34;  - \u0026#34;s3:PutObject\u0026#34;  - \u0026#34;s3:DeleteObject\u0026#34;  Resource: \u0026#39;*\u0026#39;  - Effect: \u0026#34;Allow\u0026#34;  Action:  - \u0026#34;s3:GetObject\u0026#34;  Resource: !Join  - \u0026#34;\u0026#34;  - - \u0026#34;arn:aws:s3:::\u0026#34;  - !Ref DocumentStoreBucketName  - /protected/*   # Assigns the roles to the Identity Pool  IdentityPoolRoleMapping:  Type: \u0026#34;AWS::Cognito::IdentityPoolRoleAttachment\u0026#34;  Properties:  IdentityPoolId: !Ref FcjDMSUserPoolIdentityPool  Roles:  authenticated: !GetAtt CognitoAuthorizedRole.Arn  unauthenticated: !GetAtt CognitoUnAuthorizedRole.Arn Run the following commands:  sam build sam deploy Next, we will use amplify to import authentication and storage into our web application. Run the following command at the root of the front-end project.  amplify init   Entering follow the below information:\n? Enter a name for the project fcjdms\nThe following configuration will be applied:\nProject information\n| Name: fcjdms\n| Environment: dev\n| Default editor: Visual Studio Code\n| App type: javascript\n| Javascript framework: react\n| Source Directory Path: src\n| Distribution Directory Path: build\n| Build Command: npm run-script build\n| Start Command: npm run-script start\n? Initialize the project with the above configuration? Yes\nUsing default provider awscloudformation\n? Select the authentication method you want to use: AWS profile\nFor more information on AWS Profiles, see:\nhttps://docs.aws.amazon.com/cli/latest/userguide/cli-configure-profiles.html\n? Please choose the profile you want to use default\n? Help improve Amplify CLI by sharing non sensitive configurations on failures (y/N) › No\n  If you have not downloaded the front-end project, run the following commands:\ngit clone https://github.com/AWS-First-Cloud-Journey/FCJ-Serverless-DMS\ncd FCJ-Serverless-DMS\nnpm install\n Run the following command to import authentication into project:  amplify import auth  Select Cognito User Pool and Identity Pool for What type of auth resource do you want to import?  Run the following command to import storage into project:  amplify import storage  Select S3 bucket - Content (Images, audio, video, etc.) for Select from one of the below mentioned services Select the bucket you created from the above steps  Run the command: amplify push to update cloud resources:  "
},
{
	"uri": "/",
	"title": "Serverless - Deploying Applications with AWS SAM",
	"tags": [],
	"description": "",
	"content": "Serverless - Deploying Applications with AWS SAM Overview In the first two articles of this series, we know how to build a simple serverless web application using the AWS console. To build the serverless application faster, AWS provides users with the AWS Serverless Application Model (SAM) service, which is an open-source framework for building a serverless applications. It provides shorthand syntax to express functions, APIs, databases, and event source mappings. You define the application you want with just a few lines per resource and model it using YAML. During deployment, SAM transforms and expands the SAM syntax into AWS CloudFormation syntax. Then, CloudFormation provides the resources to the user.\nIn this workshop, we will rebuild the previous web application with AWS SAM.\nThe architecture of the application we will build:\nContent  Authentication And Storage Config APIs And Lambda Function Test API With Front-end Cleanup  "
},
{
	"uri": "/2-config-api-and-lambda-function/",
	"title": "Config APIs And Lambda Function",
	"tags": [],
	"description": "",
	"content": " Add the following code to template.yaml file in sam project. This code block describe a DynamoDB table with a Partition key - user id and a Sort key - file name.   # Create a table to storage document informations  DocsTable:  Type: AWS::DynamoDB::Table  Properties:  TableName: Documents  BillingMode: PAY_PER_REQUEST  AttributeDefinitions:  - AttributeName: user_id  AttributeType: S  - AttributeName: file  AttributeType: S  KeySchema:  - AttributeName: user_id  KeyType: HASH  - AttributeName: file  KeyType: RANGE  StreamSpecification:  StreamViewType: NEW_IMAGE   # Create a table to storage general informations  GeneralTable:  Type: AWS::DynamoDB::Table  Properties:  TableName: General  BillingMode: PAY_PER_REQUEST  AttributeDefinitions:  - AttributeName: id  AttributeType: S  KeySchema:  - AttributeName: id  KeyType: HASH Add the following code to template.yaml file to config 5 lambda functions:  upload_doc list_docs delete_doc upload_general_infor get_general_infor     # Lambda function to scan all document by user id  DocsList:  Type: AWS::Serverless::Function  Properties:  CodeUri: lambda/list_docs  Handler: list_docs.lambda_handler  Runtime: python3.9  FunctionName: list_docs  Architectures:  - x86_64  Policies:  - Statement:  - Sid: ReadDynamoDB  Effect: Allow  Action:  - dynamodb:Scan  - dynamodb:Query  Resource:  - !GetAtt DocsTable.Arn  Events:  ListDocs:  Type: Api  Properties:  Path: /docs/{id}  Method: get  RestApiId: !Ref DocApi  Environment:  Variables:  TABLE_NAME: !Ref DocsTable   # Lambda function to upload documents  DocsUpload:  Type: AWS::Serverless::Function  Properties:  CodeUri: lambda/upload_doc  Handler: upload_doc.lambda_handler  Runtime: python3.9  FunctionName: upload_doc  Architectures:  - x86_64  Policies:  - Statement:  - Sid: WriteToDynamoDB  Effect: Allow  Action:  - dynamodb:PutItem  Resource:  - !GetAtt DocsTable.Arn  Events:  UpoadDocs:  Type: Api  Properties:  Path: /docs  Method: post  RestApiId: !Ref DocApi  Environment:  Variables:  TZ: Asia/Jakarta  TABLE_NAME: !Ref DocsTable   # Lambda function to delete documents by user id  DocsDelete:  Type: AWS::Serverless::Function  Properties:  CodeUri: lambda/delete_doc  Handler: delete_doc.lambda_handler  Runtime: python3.9  FunctionName: delete_doc  Architectures:  - x86_64  Policies:  - Statement:  - Sid: DeleteItems  Effect: Allow  Action:  - dynamodb:DeleteItem  - dynamodb:GetItem  - dynamodb:Query  Resource:  - !GetAtt DocsTable.Arn  Events:  DeleteDoc:  Type: Api  Properties:  Path: /docs/{id}  Method: delete  RestApiId: !Ref DocApi  Environment:  Variables:  TABLE_NAME: !Ref DocsTable   GeneralInforUpload:  Type: AWS::Serverless::Function  Properties:  CodeUri: lambda/upload_general_infor  Handler: upload_general_infor.lambda_handler  Runtime: python3.9  FunctionName: upload_general_infor  Architectures:  - x86_64  Policies:  - Statement:  - Sid: DeleteItems  Effect: Allow  Action:  - dynamodb:PutItem  Resource:  - !GetAtt GeneralTable.Arn  Events:  DeleteDoc:  Type: Api  Properties:  Path: /docs/{id}/gen/  Method: post  RestApiId: !Ref DocApi  Environment:  Variables:  TABLE_NAME: !Ref GeneralTable   GeneralInforGet:  Type: AWS::Serverless::Function  Properties:  CodeUri: lambda/get_general_infor  Handler: get_general_infor.lambda_handler  Runtime: python3.9  FunctionName: get_general_infor  Architectures:  - x86_64  Policies:  - Statement:  - Sid: DeleteItems  Effect: Allow  Action:  - dynamodb:GetItem  - dynamodb:Query  Resource:  - !GetAtt GeneralTable.Arn  Events:  DeleteDoc:  Type: Api  Properties:  Path: /docs/{id}/gen/  Method: get  RestApiId: !Ref DocApi  Environment:  Variables:  TABLE_NAME: !Ref GeneralTable Download the following file and add it to the root directory of the sam project. This file describes the APIs that we need.    Swagger   swagger.yaml  (6 ko)    Add the following code block to the bottom of template.yaml file to import swagger.yaml file.   # Create REST Api  DocApi:  Type: AWS::Serverless::Api  Properties:  StageName: dev  DefinitionBody:  \u0026#39;Fn::Transform\u0026#39;:  Name: \u0026#39;AWS::Include\u0026#39;  Parameters:  Location: \u0026#34;./swagger.yaml\u0026#34; Create folder and file: lambda/list_docs/list_docs.py Add the following code block to list_docs.py file  import json import boto3 import os from decimal import * from boto3.dynamodb.types import TypeDeserializer  dynamodb = boto3.client(\u0026#39;dynamodb\u0026#39;) serializer = TypeDeserializer()  class DecimalEncoder(json.JSONEncoder):  def default(self, obj):  if isinstance(obj, Decimal):  return str(obj)  return json.JSONEncoder.default(self, obj)  def deserialize(data):  if isinstance(data, list):  return [deserialize(v) for v in data]   if isinstance(data, dict):  try:  return serializer.deserialize(data)  except TypeError:  return {k: deserialize(v) for k, v in data.items()}  else:  return data  def lambda_handler(event, context):  table_name = os.environ[\u0026#39;TABLE_NAME\u0026#39;]  user_id = event[\u0026#39;pathParameters\u0026#39;][\u0026#39;id\u0026#39;]  print(user_id)  docs = dynamodb.query(  TableName=table_name,  KeyConditionExpression=\u0026#34;user_id = :id\u0026#34;,  ExpressionAttributeValues={ \u0026#34;:id\u0026#34;: { \u0026#39;S\u0026#39;: user_id } }  )   format_data_docs = deserialize(docs[\u0026#34;Items\u0026#34;])  # TODO implement  return {  \u0026#34;statusCode\u0026#34;: 200,  \u0026#34;headers\u0026#34;: {  \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;,  \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;,  \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET,PUT,POST,DELETE, OPTIONS\u0026#34;,  \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method,X-Access-Token,XKey,Authorization\u0026#34;  },  \u0026#34;body\u0026#34;: json.dumps(format_data_docs, cls=DecimalEncoder)  } Similarly, create upload_doc/upload_doc.py folder and file in lambda folder. Next copy the code below for the created file.  import json import boto3 import os from datetime import datetime, timezone  dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) client_cloudwatch = boto3.client(\u0026#39;cloudwatch\u0026#39;)  def lambda_handler(event, context):  table_name = os.environ[\u0026#39;TABLE_NAME\u0026#39;]  now = datetime.now(tz=timezone.utc)  dt_string = now.strftime(\u0026#34;%d/%m/%Y %H:%M:%S\u0026#34;)  doc_data = json.loads(event[\u0026#34;body\u0026#34;])   path = \u0026#34;protected/{}/{}\u0026#34;.format(doc_data[\u0026#39;identityId\u0026#39;], doc_data[\u0026#39;file\u0026#39;])  doc_data.update({\u0026#34;path\u0026#34;: path, \u0026#34;modified\u0026#34;: dt_string})  table = dynamodb.Table(table_name)  table.put_item(Item = doc_data)   # TODO implement  return {  \u0026#39;statusCode\u0026#39;: 200,  \u0026#39;body\u0026#39;: \u0026#39;successfully upload!\u0026#39;,  \u0026#39;headers\u0026#39;: {  \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;,  \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Access-Control-Allow-Headers, Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method,X-Access-Token, XKey, Authorization\u0026#34;,  \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;,  \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET,PUT,POST,DELETE,OPTIONS\u0026#34;  }  }  Similar with lambda/delete_doc/delete_doc.py file.  import json import boto3 import os  client = boto3.resource(\u0026#39;dynamodb\u0026#39;)  def lambda_handler(event, context):  # TODO implement  table_name = os.environ[\u0026#39;TABLE_NAME\u0026#39;]  error = None  doc_pk = event[\u0026#39;pathParameters\u0026#39;][\u0026#39;id\u0026#39;]  print(\u0026#34;doc_pk \u0026#34;, doc_pk)  doc_sk = event[\u0026#39;queryStringParameters\u0026#39;][\u0026#39;file\u0026#39;]  print(\u0026#34;doc_sk \u0026#34;, doc_sk)  table = client.Table(table_name)  key = {  \u0026#39;user_id\u0026#39;:doc_pk,  \u0026#39;file\u0026#39;: doc_sk  }   try:  table.delete_item(Key = key)  except Exception as e:  error = e    except Exception as e:  error = e   if error is None:  message = \u0026#39;successfully document item!\u0026#39;  else:  print(error)  message = \u0026#39;delete document fail\u0026#39;   return {  \u0026#39;statusCode\u0026#39;: 200,  \u0026#39;body\u0026#39;: message,  \u0026#39;headers\u0026#39;: {  \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;,  \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;*\u0026#39;  },  }  Similar with lambda/upload_general_infor/upload_general_infor.py file.  import json import boto3 import os dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) def lambda_handler(event, context): table_name = os.environ[\u0026#39;TABLE_NAME\u0026#39;] data = json.loads(event[\u0026#34;body\u0026#34;]) table = dynamodb.Table(table_name) data.update({\u0026#34;id\u0026#34;: event[\u0026#39;pathParameters\u0026#39;][\u0026#39;id\u0026#39;]}) table.put_item(Item = data) # TODO implement return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: \u0026#39;successfully upload!\u0026#39;, \u0026#39;headers\u0026#39;: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Access-Control-Allow-Headers, Origin, Accept, X-Requested-With, Content-Type, Access-Control-Request-Method,X-Access-Token, XKey, Authorization\u0026#34;, \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET,PUT,POST,DELETE,OPTIONS\u0026#34; } }  Similar with lambda/get_general_infor/get_general_infor.py file.  import json import boto3 import os from decimal import * from boto3.dynamodb.types import TypeDeserializer dynamodb = boto3.client(\u0026#39;dynamodb\u0026#39;) serializer = TypeDeserializer() class DecimalEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, Decimal): return str(obj) return json.JSONEncoder.default(self, obj) def deserialize(data): if isinstance(data, list): return [deserialize(v) for v in data] if isinstance(data, dict): try: return serializer.deserialize(data) except TypeError: return {k: deserialize(v) for k, v in data.items()} else: return data def lambda_handler(event, context): # TODO implement table_name = os.environ[\u0026#39;TABLE_NAME\u0026#39;] user_id = event[\u0026#39;pathParameters\u0026#39;][\u0026#39;id\u0026#39;] print(user_id) data = dynamodb.query( TableName=table_name, KeyConditionExpression=\u0026#34;id = :id\u0026#34;, ExpressionAttributeValues={ \u0026#34;:id\u0026#34;: { \u0026#39;S\u0026#39;: user_id } } ) format_data = deserialize(data[\u0026#34;Items\u0026#34;]) return { \u0026#34;statusCode\u0026#34;: 200, \u0026#34;headers\u0026#34;: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;Access-Control-Allow-Origin\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Access-Control-Allow-Methods\u0026#34;: \u0026#34;GET,PUT,POST,DELETE, OPTIONS\u0026#34;, \u0026#34;Access-Control-Allow-Headers\u0026#34;: \u0026#34;Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method,X-Access-Token,XKey,Authorization\u0026#34; }, \u0026#34;body\u0026#34;: json.dumps(format_data, cls=DecimalEncoder) #\u0026#34;body\u0026#34;: format_data } Run the following command to build and deploy the sam project after updating:  sam build sam deploy While you wait for CloudFormation to complete, you can learn about the swagger.yaml file. The next part we will perform operations on the Front-end to test the operation of the APIs.\n"
},
{
	"uri": "/1-authenication-and-storage/1-2-deploy-front-end/",
	"title": "Deploy Front-end",
	"tags": [],
	"description": "",
	"content": " Add the following code block at Prarameters section of template.yaml file in sam project:   WebStoreBucketName:  Type: String  Default: fcjdmswebstore  Change the Default value to change bucket name\n Add the following code below the S3 bucket description in section 1.1. This code block describes the bucket that allows public access and enables website hosting:   FcjDMSWebStore:  Type: AWS::S3::Bucket  Properties:  BucketName: !Ref WebStoreBucketName  PublicAccessBlockConfiguration:  BlockPublicAcls: \u0026#34;false\u0026#34;  BlockPublicPolicy: \u0026#34;false\u0026#34;  WebsiteConfiguration:  IndexDocument: \u0026#39;index.html\u0026#39;   FcjDMSWebStorePolicy:  Type: AWS::S3::BucketPolicy  Properties:  Bucket: !Ref FcjDMSWebStore  PolicyDocument:  Version: 2012-10-17  Statement:  - Action:  - \u0026#34;s3:GetObject\u0026#34;  Effect: Allow  Principal: \u0026#34;*\u0026#34;  Resource: !Join  - \u0026#34;\u0026#34;  - - \u0026#34;arn:aws:s3:::\u0026#34;  - !Ref FcjDMSWebStore  - /* Run the following commands to build and deploy sam project again:  sam build sam deploy Back to the root of the Front-end project, run the following command:  yarn build aws s3 cp build s3://BUCKET_NAME --recursive Replace BUCKET_NAME with the name of the bucket you just created to host the static website, such as: aws s3 cp build s3://fcjdmswebstore --recursive\nOpen Amazon S3 console   Select just created bucket  Select Properties tab and scroll down to bottom. Click website\u0026rsquo;s URL  Click Sign up  Enter user name, email và password. Then click Sign up  Open your email to get verify code and enter into the web. Then click Submit  Back to Cognito User Pool console, click User tab so you will see the account you just registered.  Sign in to website with the account you just registered.  Logged in successfully  Select My Profile on the left menu, then click Update profile.  Enter old and new password, then click Upadate  Click OK  Click Logout on the left menu  Click Sign in  Sign in again with the account you just updated.  You sign in successfully with the updated account.  You have finished hosting a static website on S3, authentication with Cognito, storage with S3. Next, we will set up the REST API for the application.\n"
},
{
	"uri": "/3-test-api-with-front-end/",
	"title": "Test API With Front-end",
	"tags": [],
	"description": "",
	"content": "We will perform the document upload, document download, and delete document functions to test the working of the APIs.\n Open the console of fcjdms stack, click to id of DocAPI  Select Stages, then expand dev stage and record the API\u0026rsquo;s URL  Open constant.js file in src folder of front-end project. Relpace value of APP_API_URL with your URL:   Open the src/component/Home/Upload.js file in the application\u0026rsquo;s source code directory and uncomment the code that calls the API to write data to DynamoDB.  Build and upload build folder to s3 with the following commmand:  yarn build aws s3 cp build s3://BUCKET_NAME --recursive Replace BUCKET_NAME with the name of the bucket you created to host the website\nBack to web application and reload web page.   Click Upload  Click Add files and select the files you want to upload. Then click Upload   Select My Profile to view information about file numbers and used storage  Select My Document on the left menu to view all uploaded files. Then click Select  Check to files that you want to delete and click Delete   Click OK to confirm deletion  You will see the deleted files and you can download them if you click the Download icon  Select Home on the left menu, you will see the information has been updated  You can open the S3 bucket and DynamoDB table to examine objects and data. We have completed the deployment of a serverless application with SAM.\n"
},
{
	"uri": "/4-cleanup/",
	"title": "Cleanup",
	"tags": [],
	"description": "",
	"content": " Empty S3 bucket   Run the command: aws s3 rm s3://BUCKET_NAME --recursive Replace BUCKET_NAME with bucket name to empty: fcjdmswebstore, fcjdmsstore  Run the following commands at the root of the front-end project:  amplify remove storage amplify remove auth amplify push amplify delete Delete CloudFormation stacks   Execute the command to delete the AWS SAM application: sam delete --stack-name fcjdmsapp Execute the command to empty S3 bucket: aws s3 rm s3://BUCKET_NAME --recursive Replace BUCKET_NAME with bucket names starting with: aws-sam-cli-managed-default-samclisourcebucket- Open Amazon S3 console Selecting the bucket name start with aws-sam-cli-managed-default-samclisourcebucket- Click Show versions Select the fcjdmsapp folder Select all objects Click Delete Enter permanently delete Click Delete Run the command to stack: sam delete --stack-name aws-sam-cli-managed-default  "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]